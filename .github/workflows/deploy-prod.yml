name: Deploy Condor to EC2

on:
  push:
  workflow_dispatch: {}
  release:
    types: [published]

permissions:
  contents: read
  packages: read

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: ðŸš€ Deploy via SSH (pull + up + migrate)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.EC2_HOST }}          # de tus VARS
          username: ${{ vars.EC2_USER }}      # de tus VARS (ubuntu)
          key: ${{ secrets.EC2_SSH_KEY }}     # de tus SECRETS (clave privada PEM)
          port: 22
          script_stop: true
          command_timeout: 30m
          # Enviar estas envs al host remoto
          envs: >
            GHCR_USERNAME,GH_AUTOMATION_TOKEN,DJANGO_SECRET_KEY,DATABASE_URL,
            OWNER,IMAGE_PREFIX,BACKEND_TAG,FRONTEND_TAG,CRON_TAG,
            PUBLIC_API_BASE_URL,PUBLIC_CLIENTE_ID,PUBLIC_NOMBRE_CLIENTE,
            PUBLIC_COLOR_PRIMARIO,PUBLIC_COLOR_SECUNDARIO,REDIS_URL,
            ALLOWED_HOSTS,CSRF_TRUSTED_ORIGINS
        env:
          # Mapear Secrets/Vars del repo â†’ envs del runner (luego viajan por with.envs)
          GHCR_USERNAME:           ${{ secrets.GHCR_USERNAME }}
          GH_AUTOMATION_TOKEN:     ${{ secrets.GH_AUTOMATION_TOKEN }}
          DJANGO_SECRET_KEY:       ${{ secrets.DJANGO_SECRET_KEY }}
          DATABASE_URL:            ${{ secrets.DATABASE_URL }}

          OWNER:                   ${{ vars.OWNER }}
          IMAGE_PREFIX:            ${{ vars.IMAGE_PREFIX }}
          BACKEND_TAG:             ${{ vars.BACKEND_TAG }}
          FRONTEND_TAG:            ${{ vars.FRONTEND_TAG }}
          CRON_TAG:                ${{ vars.CRON_TAG }}

          PUBLIC_API_BASE_URL:     ${{ vars.PUBLIC_API_BASE_URL }}
          PUBLIC_CLIENTE_ID:       ${{ vars.PUBLIC_CLIENTE_ID }}
          PUBLIC_NOMBRE_CLIENTE:   ${{ vars.PUBLIC_NOMBRE_CLIENTE }}
          PUBLIC_COLOR_PRIMARIO:   ${{ vars.PUBLIC_COLOR_PRIMARIO }}
          PUBLIC_COLOR_SECUNDARIO: ${{ vars.PUBLIC_COLOR_SECUNDARIO }}

          REDIS_URL:               ${{ vars.REDIS_URL }}
          ALLOWED_HOSTS:           ${{ vars.ALLOWED_HOSTS }}
          CSRF_TRUSTED_ORIGINS:    ${{ vars.CSRF_TRUSTED_ORIGINS }}
        script: |
          set -euo pipefail
          trap 'echo "âŒ Error en lÃ­nea $LINENO" >&2' ERR
          log(){ echo "[$(date -Is)] $*"; }
          fail(){ echo "âŒ $1" >&2; exit 1; }
          req(){ [ -n "${!1:-}" ] || fail "Falta variable requerida: $1"; }

          # ==== Validaciones (todas vienen de tus Secrets/Vars) ====
          for v in GHCR_USERNAME GH_AUTOMATION_TOKEN DJANGO_SECRET_KEY DATABASE_URL OWNER \
                   IMAGE_PREFIX BACKEND_TAG FRONTEND_TAG CRON_TAG PUBLIC_API_BASE_URL \
                   PUBLIC_CLIENTE_ID PUBLIC_NOMBRE_CLIENTE PUBLIC_COLOR_PRIMARIO \
                   PUBLIC_COLOR_SECUNDARIO REDIS_URL ALLOWED_HOSTS CSRF_TRUSTED_ORIGINS; do
            req "$v"
          done

          # ==== Ajuste CSRF: si no tiene puerto, le agrego :8080 ====
          if ! echo "${CSRF_TRUSTED_ORIGINS}" | grep -qE ':[0-9]{2,5}$'; then
            CSRF_TRUSTED_ORIGINS="${CSRF_TRUSTED_ORIGINS}:8080"
          fi

          # ==== Paths ====
          sudo mkdir -p /opt/condor
          sudo chown -R "$USER":"$USER" /opt/condor
          cd /opt/condor

          # ==== Pre-chequeo: compose local ====
          [ -f docker-compose-prod.yml ] || fail "Falta /opt/condor/docker-compose-prod.yml en la EC2"

          # ==== Render .env.prod ====
          log "[+] Render .env.prod"
          cat > .env.prod <<EOF
          DJANGO_SECRET_KEY=${DJANGO_SECRET_KEY}
          DATABASE_URL=${DATABASE_URL}
          ALLOWED_HOSTS=${ALLOWED_HOSTS}
          CSRF_TRUSTED_ORIGINS=${CSRF_TRUSTED_ORIGINS}
          REDIS_URL=${REDIS_URL}

          PUBLIC_API_BASE_URL=${PUBLIC_API_BASE_URL}
          PUBLIC_CLIENTE_ID=${PUBLIC_CLIENTE_ID}
          PUBLIC_NOMBRE_CLIENTE=${PUBLIC_NOMBRE_CLIENTE}
          PUBLIC_COLOR_PRIMARIO=${PUBLIC_COLOR_PRIMARIO}
          PUBLIC_COLOR_SECUNDARIO=${PUBLIC_COLOR_SECUNDARIO}

          OWNER=${OWNER}
          IMAGE_PREFIX=${IMAGE_PREFIX}
          BACKEND_TAG=${BACKEND_TAG}
          FRONTEND_TAG=${FRONTEND_TAG}
          CRON_TAG=${CRON_TAG}
          EOF

          log "[i] Preview .env (sin secretos sensibles)"
          grep -E '^(ALLOWED_HOSTS|CSRF_TRUSTED_ORIGINS|PUBLIC_|OWNER|IMAGE_PREFIX|.*TAG)=' .env.prod || true

          # ==== Validar compose ====
          log "[+] Validando compose"
          docker compose --env-file .env.prod -f docker-compose-prod.yml config >/dev/null

          # ==== GHCR login ====
          log "[+] Docker login GHCR"
          echo "${GH_AUTOMATION_TOKEN}" | docker login ghcr.io -u "${GHCR_USERNAME}" --password-stdin

          # ==== Pull & Up ====
          log "[+] Pull imÃ¡genes"
          docker compose --env-file .env.prod -f docker-compose-prod.yml pull

          log "[+] Levantando stack"
          docker compose --env-file .env.prod -f docker-compose-prod.yml up -d

          # ==== Migraciones & Checks ====
          log "[+] Migraciones Django"
          docker compose --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py migrate --noinput

          log "[+] Django check --deploy (no-fail)"
          docker compose --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py check --deploy || true

          # ==== Smoke tests ====
          log "[+] Smoke /healthz"
          curl -fsS http://localhost:8080/healthz
          curl -fsS http://localhost:8080/api/healthz || true

          log "[âœ“] Deploy OK"
