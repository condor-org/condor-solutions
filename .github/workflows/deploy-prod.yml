name: Build and deploy

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Tag del release (ej: v0.0.12)"
        required: true
        type: string
      platforms:
        description: "Plataformas para buildx"
        required: true
        type: choice
        default: "linux/amd64"
        options:
          - "linux/amd64"
          - "linux/amd64,linux/arm64"

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  # Para release usa el tag del release; para manual usa el input
  RELEASE_TAG: ${{ github.event_name == 'workflow_dispatch' && inputs.release_tag || github.event.release.tag_name }}
  # Para release default amd64; para manual usa el input de choice
  PLATFORMS: ${{ github.event_name == 'workflow_dispatch' && inputs.platforms || 'linux/amd64' }}

jobs:
  build-and-push:
    name: Build & Push images
    runs-on: ubuntu-latest
    environment: prod
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: backend
            context: ./backend
            file: ./backend/docker/Dockerfile
          - name: cron
            context: ./backend
            file: ./backend/docker/Dockerfile.cron
          - name: frontend
            context: ./frontend-padel
            file: ./frontend-padel/docker/Dockerfile

    steps:
      - uses: actions/checkout@v4

      - id: lower
        run: echo "OWNER_LC=$(echo '${{ github.repository_owner }}' | tr '[:upper:]' '[:lower:]')" >> $GITHUB_OUTPUT

      - uses: docker/setup-qemu-action@v3
      - uses: docker/setup-buildx-action@v3

      - uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ steps.lower.outputs.OWNER_LC }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/build-push-action@v6
        with:
          context: ${{ matrix.context }}
          file: ${{ matrix.file }}
          platforms: ${{ env.PLATFORMS }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          tags: ${{ env.REGISTRY }}/${{ steps.lower.outputs.OWNER_LC }}/condor-${{ matrix.name }}:${{ env.RELEASE_TAG }}
          push: true

  deploy:
    name: Deploy to prod
    runs-on: ubuntu-latest
    environment: prod
    needs: build-and-push
    permissions:
      contents: read
      packages: read
    env:
      # Variables para el compose remoto y nombres de imágenes
      OWNER: ${{ vars.OWNER }}
      IMAGE_PREFIX: ${{ vars.IMAGE_PREFIX }}
      BACKEND_TAG: ${{ env.RELEASE_TAG }}
      FRONTEND_TAG: ${{ env.RELEASE_TAG }}
      CRON_TAG: ${{ env.RELEASE_TAG }}
      LETSENCRYPT_EMAIL: ${{ vars.LETSENCRYPT_EMAIL || 'admin@cnd-ia.com' }}
    steps:
      - name: Conectar a EC2 y desplegar
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.EC2_HOST }}
          username: ${{ vars.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            trap 'echo "❌ Error en línea $LINENO" >&2' ERR
            cd /opt/condor

            echo "[+] Obtener rama default y bajar SOLO docker-compose-prod.yml"
            TOKEN="${{ secrets.GH_AUTOMATION_TOKEN }}"
            REPO="condor-ai-solutions/condor"

            DEFAULT_BRANCH=$(
              curl -fsSL -H "Authorization: token ${TOKEN}" \
                "https://api.github.com/repos/${REPO}" \
              | awk -F'"' '/"default_branch":/ {print $4; exit}'
            )
            echo "[i] Default branch: ${DEFAULT_BRANCH:-<desconocida>}"
            [ -n "${DEFAULT_BRANCH:-}" ] || { echo "❌ No pude detectar la default branch"; exit 1; }

            # Backup si ya existe
            [ -f docker-compose-prod.yml ] && cp -a docker-compose-prod.yml docker-compose-prod.yml.bak.$(date +%F_%H%M) || true

            # Descargar el archivo exacto desde la rama default
            curl -fsSL \
              -H "Authorization: token ${TOKEN}" \
              -H "Accept: application/vnd.github.raw" \
              "https://api.github.com/repos/${REPO}/contents/docker-compose-prod.yml?ref=${DEFAULT_BRANCH}" \
              -o docker-compose-prod.yml

            # Validación básica
            test -s docker-compose-prod.yml || { echo "❌ No se pudo descargar docker-compose-prod.yml"; exit 1; }
            echo "[OK] docker-compose-prod.yml actualizado desde ${DEFAULT_BRANCH}"

            echo "[+] Docker login GHCR"
            echo "${{ secrets.GH_AUTOMATION_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin

            echo "[+] Render .env.prod"
            printf '%s\n' \
              "DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}" \
              "DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,${{ vars.ALLOWED_HOSTS }}" \
              "CSRF_TRUSTED_ORIGINS=${{ vars.CSRF_TRUSTED_ORIGINS }}" \
              "DJANGO_ENV=prod" \
              "DJANGO_SECURE_SSL_REDIRECT=False" \
              "DJANGO_HSTS_SECONDS=0" \
              "REDIS_URL=${{ vars.REDIS_URL }}" \
              "PUBLIC_API_BASE_URL=${{ vars.PUBLIC_API_BASE_URL }}" \
              "PUBLIC_CLIENTE_ID=${{ vars.PUBLIC_CLIENTE_ID }}" \
              "PUBLIC_NOMBRE_CLIENTE=${{ vars.PUBLIC_NOMBRE_CLIENTE }}" \
              "PUBLIC_COLOR_PRIMARIO=${{ vars.PUBLIC_COLOR_PRIMARIO }}" \
              "PUBLIC_COLOR_SECUNDARIO=${{ vars.PUBLIC_COLOR_SECUNDARIO }}" \
              "POSTGRES_DB=${{ vars.POSTGRES_DB }}" \
              "POSTGRES_USER=${{ vars.POSTGRES_USER }}" \
              "POSTGRES_HOST=${{ vars.POSTGRES_HOST }}" \
              "POSTGRES_PORT=${{ vars.POSTGRES_PORT }}" \
              "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}" \
              "OWNER=${{ env.OWNER }}" \
              "IMAGE_PREFIX=${{ env.IMAGE_PREFIX }}" \
              "BACKEND_TAG=${{ env.BACKEND_TAG }}" \
              "FRONTEND_TAG=${{ env.FRONTEND_TAG }}" \
              "CRON_TAG=${{ env.CRON_TAG }}" \
              "GCP_SA_CLIENT_EMAIL=${{ secrets.GCP_SA_CLIENT_EMAIL }}" \
              "GCP_SA_PROJECT_ID=${{ secrets.GCP_SA_PROJECT_ID }}" \
              "GOOGLE_CREDS=${{ secrets.GOOGLE_CREDS }}" \
              "VISION_OCR_BUCKET=${{ secrets.VISION_OCR_BUCKET }}" \
              "GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}" \
              "GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}" \
              "STATE_HMAC_SECRET=${{ secrets.STATE_HMAC_SECRET }}" \
              "GOOGLE_ISSUER=${{ vars.GOOGLE_ISSUER }}" \
              "GOOGLE_JWKS_URL=${{ vars.GOOGLE_JWKS_URL }}" \
              "OAUTH_REDIRECT_URI=${{ vars.OAUTH_REDIRECT_URI }}" \
              "FEATURE_OAUTH_INVITES=${{ vars.FEATURE_OAUTH_INVITES }}" \
              "OAUTH_AUTO_PROVISION=${{ vars.OAUTH_AUTO_PROVISION }}" \
              "OAUTH_ALLOWED_EMAIL_DOMAIN=${{ vars.OAUTH_ALLOWED_EMAIL_DOMAIN }}" \
              "PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.PUBLIC_GOOGLE_CLIENT_ID }}" \
              "PUBLIC_OAUTH_REDIRECT_URI=${{ vars.PUBLIC_OAUTH_REDIRECT_URI }}" \
              > .env.prod

            docker system prune -af --volumes

            echo "[+] Verificando compose"
            test -f docker-compose-prod.yml || { echo "FALTA docker-compose-prod.yml"; ls -la; exit 2; }

            echo "[+] Preparar credencial Cloudflare para certbot (DNS-01)"
            mkdir -p letsencrypt
            cat > letsencrypt/cloudflare.ini <<'EOF'
            dns_cloudflare_api_token=${{ secrets.CF_DNS_API_TOKEN }}
            EOF
            chmod 600 letsencrypt/cloudflare.ini

            echo "[+] Asegurar volumen de certificados (docker)"
            docker volume inspect condor_certbot_etc >/dev/null 2>&1 || docker volume create --name condor_certbot_etc >/dev/null

            echo "[+] Emitir/renovar wildcard (*.cnd-ia.com) con Certbot (DNS-01 Cloudflare)"
            docker run --rm \
              -v condor_certbot_etc:/etc/letsencrypt \
              -v "$PWD/letsencrypt:/secrets:ro" \
              certbot/dns-cloudflare:latest certonly \
                --dns-cloudflare \
                --dns-cloudflare-credentials /secrets/cloudflare.ini \
                -d cnd-ia.com -d '*.cnd-ia.com' \
                --agree-tos --non-interactive \
                -m '${{ env.LETSENCRYPT_EMAIL }}' || true

            echo "[+] Listar certificados disponibles"
            docker run --rm -v condor_certbot_etc:/data alpine sh -lc "ls -l /data/live/cnd-ia.com || true"

            echo "[+] Pull imágenes"
            docker compose --env-file .env.prod -f docker-compose-prod.yml pull

            echo "[+] Levantando stack"
            docker compose --env-file .env.prod -f docker-compose-prod.yml up -d --force-recreate

            echo "[+] Esperando servicios healthy"
            for i in $(seq 1 40); do
              B=$(docker inspect -f '{{.State.Health.Status}}' backend_condor 2>/dev/null || echo "starting")
              F=$(docker inspect -f '{{.State.Health.Status}}' frontend_condor 2>/dev/null || echo "starting")
              echo "  backend=$B | frontend=$F"
              if [ "$B" = "healthy" ] && [ "$F" = "healthy" ]; then break; fi
              sleep 3
            done

            echo "[+] Migraciones y checks"
            docker compose --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py migrate --noinput
            docker compose --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py check --deploy || true

            echo "[+] Smoke tests (HTTP interno en proxy; HTTPS depende de tu nginx.conf/443)"
            curl -fsS http://localhost/ >/dev/null
            curl -fsS http://localhost/config.js >/dev/null
            curl -fsS http://localhost/api/healthz >/dev/null || true

            echo "[✓] Deploy OK"
