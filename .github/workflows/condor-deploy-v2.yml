name: Condor Deploy v2 (DEV/PROD)

on:
  release:
    types: [published]  # Solo cuando se publica un release
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente a deployar'
        required: true
        default: 'dev'
        type: choice
        options: [dev, prod]
      release_tag:
        description: 'Tag específico a usar (opcional)'
        required: false
        type: string
      run_bootstrap:
        description: 'Ejecutar bootstrap_condor después del deploy'
        required: false
        default: false
        type: boolean


permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  OWNER: ${{ github.repository_owner }}


jobs:
  get-latest-release:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && !inputs.release_tag
    outputs:
      latest_tag: ${{ steps.get-tag.outputs.tag }}
    steps:
      - uses: actions/checkout@v4
      - name: Get latest release tag
        id: get-tag
        run: |
          LATEST_TAG=$(gh release list --limit 1 --json tagName -q '.[0].tagName')
          echo "tag=$LATEST_TAG" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  determine-environment:
    runs-on: ubuntu-latest
    needs: [get-latest-release]
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      is_dev: ${{ steps.env.outputs.is_dev }}
      is_prod: ${{ steps.env.outputs.is_prod }}
      release_tag: ${{ steps.env.outputs.release_tag }}
    steps:
      - name: Determinar ambiente
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENV="${{ inputs.environment }}"

            if [ -n "${{ inputs.release_tag }}" ]; then
              TAG="${{ inputs.release_tag }}"
            else
              TAG="${{ needs.get-latest-release.outputs.latest_tag }}"
            fi
          else
            TAG="${{ github.event.release.tag_name }}"
            if [[ "$TAG" == *"dev"* || "$TAG" == *"beta"* || "$TAG" == *"alpha"* ]]; then ENV="dev"; else ENV="prod"; fi
          fi
          echo "environment=$ENV" >> $GITHUB_OUTPUT
          echo "is_dev=$([ "$ENV" = "dev" ] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "is_prod=$([ "$ENV" = "prod" ] && echo true || echo false)" >> $GITHUB_OUTPUT
          echo "release_tag=$TAG" >> $GITHUB_OUTPUT

  detect-changes:
    runs-on: ubuntu-latest
    needs: determine-environment
    outputs:
      backend: ${{ steps.changes.outputs.backend }}
      frontend: ${{ steps.changes.outputs.frontend }}
      cron: ${{ steps.changes.outputs.cron }}
      proxy: ${{ steps.changes.outputs.proxy }}
      any_changes: ${{ steps.any.outputs.any_changes }}
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            backend:
              - 'backend/**'
            frontend:
              - 'frontend-padel/**'
            cron:
              - 'backend/docker/Dockerfile.cron'
              - 'backend/apps/**'
            proxy:
              - 'reverse-proxy/**'
      - id: any
        run: |
          ANY=$([ "${{ steps.changes.outputs.backend }}" = "true" ] || \
                [ "${{ steps.changes.outputs.frontend }}" = "true" ] || \
                [ "${{ steps.changes.outputs.cron }}" = "true" ] && echo true || echo false)
          echo "any_changes=$ANY" >> $GITHUB_OUTPUT


  deploy-dev:
    runs-on: ubuntu-latest
    needs: [determine-environment]

    if: needs.determine-environment.outputs.is_dev == 'true'
    environment: dev
    env:
      RELEASE_TAG: ${{ needs.determine-environment.outputs.release_tag }}
    steps:
      - name: Deploy a DEV
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.EC2_HOST }}
          username: ${{ vars.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /opt/condor
            TOKEN="${{ secrets.GH_AUTOMATION_TOKEN }}"
            REPO="condor-ai-solutions/condor"

            [ -f docker-compose-dev.yml ] && cp docker-compose-dev.yml docker-compose-dev.yml.bak.$(date +%F_%H%M) || true
            [ -f docker-compose-proxy.yml ] && cp docker-compose-proxy.yml docker-compose-proxy.yml.bak.$(date +%F_%H%M) || true

            curl -fsSL -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github.raw" \
              "https://api.github.com/repos/${REPO}/contents/docker-compose-dev.yml?ref=${{ github.sha }}" \
              -o docker-compose-dev.yml
            curl -fsSL -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github.raw" \
              "https://api.github.com/repos/${REPO}/contents/docker-compose-proxy.yml?ref=${{ github.sha }}" \
              -o docker-compose-proxy.yml

            echo "${{ secrets.GH_AUTOMATION_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin

            cat > .env.dev << 'EOF'
            DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
            DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,${{ vars.ALLOWED_HOSTS }}
            CSRF_TRUSTED_ORIGINS=${{ vars.CSRF_TRUSTED_ORIGINS }}
            DJANGO_ENV=dev
            DJANGO_SECURE_SSL_REDIRECT=False
            DJANGO_HSTS_SECONDS=0
            REDIS_URL=${{ vars.REDIS_URL }}
            PUBLIC_API_BASE_URL=${{ vars.PUBLIC_API_BASE_URL }}
            PUBLIC_CLIENTE_ID=${{ vars.PUBLIC_CLIENTE_ID }}
            PUBLIC_NOMBRE_CLIENTE=${{ vars.PUBLIC_NOMBRE_CLIENTE }}
            PUBLIC_COLOR_PRIMARIO=${{ vars.PUBLIC_COLOR_PRIMARIO }}
            PUBLIC_COLOR_SECUNDARIO=${{ vars.PUBLIC_COLOR_SECUNDARIO }}
            POSTGRES_DB=${{ vars.POSTGRES_DB }}
            POSTGRES_USER=${{ vars.POSTGRES_USER }}
            POSTGRES_HOST=${{ vars.POSTGRES_HOST }}
            POSTGRES_PORT=${{ vars.POSTGRES_PORT }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            OWNER=${{ env.OWNER }}
            IMAGE_PREFIX=condor
            BACKEND_TAG_DEV=${{ env.RELEASE_TAG }}
            FRONTEND_TAG_DEV=${{ env.RELEASE_TAG }}
            CRON_TAG_DEV=${{ env.RELEASE_TAG }}
            PROXY_TAG=${{ env.RELEASE_TAG }}
            GCP_SA_CLIENT_EMAIL=${{ secrets.GCP_SA_CLIENT_EMAIL }}
            GCP_SA_PROJECT_ID=${{ secrets.GCP_SA_PROJECT_ID }}
            GOOGLE_CREDS=${{ secrets.GOOGLE_CREDS }}
            VISION_OCR_BUCKET=${{ secrets.VISION_OCR_BUCKET }}
            GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
            STATE_HMAC_SECRET=${{ secrets.STATE_HMAC_SECRET }}
            GOOGLE_ISSUER=${{ vars.GOOGLE_ISSUER }}
            GOOGLE_JWKS_URL=${{ vars.GOOGLE_JWKS_URL }}
            OAUTH_REDIRECT_URI=${{ vars.OAUTH_REDIRECT_URI }}
            FEATURE_OAUTH_INVITES=${{ vars.FEATURE_OAUTH_INVITES }}
            OAUTH_AUTO_PROVISION=${{ vars.OAUTH_AUTO_PROVISION }}
            OAUTH_ALLOWED_EMAIL_DOMAIN=${{ vars.OAUTH_ALLOWED_EMAIL_DOMAIN }}
            PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.PUBLIC_GOOGLE_CLIENT_ID }}
            PUBLIC_OAUTH_REDIRECT_URI=${{ vars.PUBLIC_OAUTH_REDIRECT_URI }}
            EOF

            docker compose -p condor_dev --env-file .env.dev -f docker-compose-dev.yml pull
            docker compose -p condor_dev --env-file .env.dev -f docker-compose-dev.yml up -d --force-recreate

            docker compose -p condor_dev --env-file .env.dev -f docker-compose-dev.yml exec -T backend_dev python manage.py migrate --noinput

            if [ "${{ inputs.run_bootstrap }}" = "true" ]; then
              docker compose -p condor_dev --env-file .env.dev -f docker-compose-dev.yml exec -T backend_dev python manage.py bootstrap_condor
            fi

  deploy-prod:
    runs-on: ubuntu-latest
    needs: [determine-environment]
    if: needs.determine-environment.outputs.is_prod == 'true'
    environment: prod
    env:
      RELEASE_TAG: ${{ needs.determine-environment.outputs.release_tag }}
    steps:
      - name: Deploy a PROD
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ vars.EC2_HOST }}
          username: ${{ vars.EC2_USER }}
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            cd /opt/condor
            TOKEN="${{ secrets.GH_AUTOMATION_TOKEN }}"
            REPO="condor-ai-solutions/condor"

            [ -f docker-compose-prod.yml ] && cp docker-compose-prod.yml docker-compose-prod.yml.bak.$(date +%F_%H%M) || true
            [ -f docker-compose-proxy.yml ] && cp docker-compose-proxy.yml docker-compose-proxy.yml.bak.$(date +%F_%H%M) || true

            curl -fsSL -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github.raw" \
              "https://api.github.com/repos/${REPO}/contents/docker-compose-prod.yml?ref=${{ github.sha }}" \
              -o docker-compose-prod.yml
            curl -fsSL -H "Authorization: token ${TOKEN}" -H "Accept: application/vnd.github.raw" \
              "https://api.github.com/repos/${REPO}/contents/docker-compose-proxy.yml?ref=${{ github.sha }}" \
              -o docker-compose-proxy.yml

            echo "${{ secrets.GH_AUTOMATION_TOKEN }}" | docker login ghcr.io -u "${{ secrets.GHCR_USERNAME }}" --password-stdin

            cat > .env.prod << 'EOF'
            DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}
            DJANGO_ALLOWED_HOSTS=localhost,127.0.0.1,${{ vars.ALLOWED_HOSTS }}
            CSRF_TRUSTED_ORIGINS=${{ vars.CSRF_TRUSTED_ORIGINS }}
            DJANGO_ENV=prod
            DJANGO_SECURE_SSL_REDIRECT=False
            DJANGO_HSTS_SECONDS=0
            REDIS_URL=${{ vars.REDIS_URL }}
            PUBLIC_API_BASE_URL=${{ vars.PUBLIC_API_BASE_URL }}
            PUBLIC_CLIENTE_ID=${{ vars.PUBLIC_CLIENTE_ID }}
            PUBLIC_NOMBRE_CLIENTE=${{ vars.PUBLIC_NOMBRE_CLIENTE }}
            PUBLIC_COLOR_PRIMARIO=${{ vars.PUBLIC_COLOR_PRIMARIO }}
            PUBLIC_COLOR_SECUNDARIO=${{ vars.PUBLIC_COLOR_SECUNDARIO }}
            POSTGRES_DB=${{ vars.POSTGRES_DB }}
            POSTGRES_USER=${{ vars.POSTGRES_USER }}
            POSTGRES_HOST=${{ vars.POSTGRES_HOST }}
            POSTGRES_PORT=${{ vars.POSTGRES_PORT }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
            OWNER=${{ env.OWNER }}
            IMAGE_PREFIX=condor
            BACKEND_TAG=${{ env.RELEASE_TAG }}
            FRONTEND_TAG=${{ env.RELEASE_TAG }}
            CRON_TAG=${{ env.RELEASE_TAG }}
            PROXY_TAG=${{ env.RELEASE_TAG }}
            GCP_SA_CLIENT_EMAIL=${{ secrets.GCP_SA_CLIENT_EMAIL }}
            GCP_SA_PROJECT_ID=${{ secrets.GCP_SA_PROJECT_ID }}
            GOOGLE_CREDS=${{ secrets.GOOGLE_CREDS }}
            VISION_OCR_BUCKET=${{ secrets.VISION_OCR_BUCKET }}
            GOOGLE_CLIENT_ID=${{ secrets.GOOGLE_CLIENT_ID }}
            GOOGLE_CLIENT_SECRET=${{ secrets.GOOGLE_CLIENT_SECRET }}
            STATE_HMAC_SECRET=${{ secrets.STATE_HMAC_SECRET }}
            GOOGLE_ISSUER=${{ vars.GOOGLE_ISSUER }}
            GOOGLE_JWKS_URL=${{ vars.GOOGLE_JWKS_URL }}
            OAUTH_REDIRECT_URI=${{ vars.OAUTH_REDIRECT_URI }}
            FEATURE_OAUTH_INVITES=${{ vars.FEATURE_OAUTH_INVITES }}
            OAUTH_AUTO_PROVISION=${{ vars.OAUTH_AUTO_PROVISION }}
            OAUTH_ALLOWED_EMAIL_DOMAIN=${{ vars.OAUTH_ALLOWED_EMAIL_DOMAIN }}
            PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.PUBLIC_GOOGLE_CLIENT_ID }}
            PUBLIC_OAUTH_REDIRECT_URI=${{ vars.PUBLIC_OAUTH_REDIRECT_URI }}
            EOF

            docker compose -p condor_prod --env-file .env.prod -f docker-compose-prod.yml pull
            docker compose -p condor_prod --env-file .env.prod -f docker-compose-prod.yml up -d --force-recreate

            docker compose -p condor_prod --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py migrate --noinput

            if [ "${{ inputs.run_bootstrap }}" = "true" ]; then
              docker compose -p condor_prod --env-file .env.prod -f docker-compose-prod.yml exec -T backend python manage.py bootstrap_condor
            fi
