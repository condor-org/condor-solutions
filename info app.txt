Aplicacion para gestionar turnos de Padel

4 posibles usuarios

Super Admin: yo due√±o de la app
Admin: Due√±o del negocio de Padel
Profesor: Profe de padel asociado con Admin
Alumno: Persona que quiere reservar turnos


Logica de la APP>
Un alumno entra a la app , elige sede, profesor, se fija los turnos disponibles para una determinada semana, en rojo los que ya estan ocupados en verde los libres. Clickea en el turno y comienza la reserva del mismo
. En pantalla aparece el alias y el monto configurado ademas de un timer de 15 minutos que es el tiempo que tiene el Alumno para completar la reserva. Para que se reserve un turno
primero tiene que estar libre. Segundo tiene que subir un comprobante de pago el cual va a ser verificado. Segun los datos de pago guardados por el admin , se chequea que el comprobante tenga
los datos correctos y una comprobado se reserva efectivamente ese turno para esa sede y ese profesor.

El Admin tiene que:
- poder agregar Profesores con una disponibilidad puntual para una o mas sedes. 
- Poder reservar turnos sin que se le exija un comprobante valido
- Poder liberar turnos
- Poder gestionar Profesores , Alumnos , Sedes.
- Poder crear los turnos de un Proferos para el mes dada su Disponibilidad

El Alumno tiene que:
- Poder elegir semana ,sede y profesor
- Poder ver turnos de esa semana asociados a ese profe y a esa sede. 
- Poder seleccionar un turno libre , subir un comprobante de pago con los datos correctos y valor correcto y reservar ese turno
- Poder ver sus reservas y sus pagos.

La vista del Profesor la dejamos para mas adelante

El backend tiene varias apps. Algunas CORE: turnos_core, pagos_core, auth_core. Que manejan turnos genericos, pagos genericos y auth generica. Y despues la especifica de esta app: turnos_padel_core

TURNOS PADEL CORE tiene estos modelos:
# apps/turnos_padel_core/models.py
from django.db import models
from apps.turnos_core.models import Lugar


class Profesor(models.Model):
    nombre = models.CharField(max_length=100)
    email = models.EmailField(unique=True, blank=True, null=True)
    telefono = models.CharField(max_length=20, blank=True, null=True)
    especialidad = models.CharField(max_length=100, blank=True, null=True)
    activo = models.BooleanField(default=True)

    # Relaci√≥n impl√≠cita a trav√©s de Disponibilidad
    sedes = models.ManyToManyField(
        Lugar,
        through="Disponibilidad",
        related_name="profesores"
    )

    def __str__(self):
        return self.nombre


class Disponibilidad(models.Model):
    profesor = models.ForeignKey("Profesor", on_delete=models.CASCADE, related_name="disponibilidades")
    lugar = models.ForeignKey(Lugar, on_delete=models.CASCADE)

    dia_semana = models.IntegerField(choices=[
        (0, "Lunes"), (1, "Martes"), (2, "Mi√©rcoles"),
        (3, "Jueves"), (4, "Viernes"), (5, "S√°bado"), (6, "Domingo")
    ])
    hora_inicio = models.TimeField()
    hora_fin = models.TimeField()
    activo = models.BooleanField(default=True)  # Permite pausar franjas sin borrar

    class Meta:
        unique_together = ("profesor", "lugar", "dia_semana", "hora_inicio", "hora_fin")

    def __str__(self):
        return f"{self.profesor} en {self.lugar} los {self.get_dia_semana_display()} de {self.hora_inicio} a {self.hora_fin}"

TURNOS CORE tiene estos

from django.db import models
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.conf import settings  # ‚Üê Usamos esto para el AUTH_USER_MODEL


class Servicio(models.Model):
    nombre = models.CharField(max_length=100)
    descripcion = models.TextField(blank=True, null=True)
    responsable = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="servicios"
    )
    lugar = models.ForeignKey("Lugar", on_delete=models.SET_NULL, null=True, blank=True)

    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.nombre} ({self.lugar})" if self.lugar else self.nombre


class Turno(models.Model):
    ESTADOS = [
        ("pendiente", "Pendiente"),
        ("confirmado", "Confirmado"),
        ("cancelado", "Cancelado"),
        ("vencido", "Vencido"),
    ]

    fecha = models.DateField()
    hora = models.TimeField()
    estado = models.CharField(max_length=20, choices=ESTADOS, default="pendiente")

    servicio = models.ForeignKey(Servicio, on_delete=models.SET_NULL, null=True, blank=True, related_name="turnos")

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    recurso = GenericForeignKey("content_type", "object_id")

    lugar = models.ForeignKey("Lugar", on_delete=models.SET_NULL, null=True, blank=True)
    usuario = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True
    )

    creado_en = models.DateTimeField(auto_now_add=True)
    actualizado_en = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ("fecha", "hora", "content_type", "object_id")

    def __str__(self):
        base = f"{self.fecha} {self.hora} reservado por {self.usuario}"
        if self.servicio:
            return f"{base} - {self.servicio}"
        return f"{base} en {self.recurso}"


class Lugar(models.Model):
    nombre = models.CharField(max_length=100)
    direccion = models.TextField(blank=True, null=True)
    referente = models.CharField(max_length=100, blank=True, null=True)
    telefono = models.CharField(max_length=20, blank=True, null=True)

    def __str__(self):
        return self.nombre

PAGOS CORE estos# condor/apps/pagos_core/models.py

from django.db import models
from django.contrib.auth import get_user_model
from django.contrib.contenttypes.fields import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from apps.turnos_core.models import Turno
from pathlib import Path

User = get_user_model()


class PagoIntento(models.Model):
    ESTADOS = [
        ("pendiente", "Pendiente"),
        ("pre_aprobado", "Preaprobado"),
        ("rechazado", "Rechazado"),
        ("confirmado", "Confirmado"),
    ]

    usuario = models.ForeignKey(User, on_delete=models.CASCADE)
    creado_en = models.DateTimeField(auto_now_add=True)
    estado = models.CharField(max_length=20, choices=ESTADOS, default="pendiente")
    monto_esperado = models.DecimalField(max_digits=10, decimal_places=2)
    moneda = models.CharField(max_length=10, default="ARS")

    alias_destino = models.CharField(max_length=100)
    cbu_destino = models.CharField(max_length=64, blank=True, null=True)

    content_type = models.ForeignKey(ContentType, on_delete=models.CASCADE)
    object_id = models.PositiveIntegerField()
    origen = GenericForeignKey("content_type", "object_id")

    tiempo_expiracion = models.DateTimeField()

    external_reference = models.CharField(max_length=100, unique=True, blank=True, null=True)
    id_transaccion_banco = models.CharField(max_length=100, blank=True, null=True)

    def __str__(self):
        return f"Pago de {self.usuario} - {self.estado}"


def comprobante_upload_path(instance, filename):
    # Guarda como media/comprobantes/turno_45/archivo.pdf
    return f"comprobantes/turno_{instance.turno.id}/{filename}"

class ComprobantePago(models.Model):
    turno = models.OneToOneField(
        Turno,
        on_delete=models.CASCADE,
        related_name="comprobante",
        null=True,      # ‚Üê permitir migrar sin datos previos
        blank=True,
    )
    archivo = models.FileField(upload_to=comprobante_upload_path)
    hash_archivo = models.CharField(max_length=64, unique=True)
    valido = models.BooleanField(default=True)
    created_at = models.DateTimeField(auto_now_add=True)

    datos_extraidos = models.JSONField(blank=True, null=True)
    nro_operacion = models.CharField(max_length=100, blank=True, null=True)
    emisor_nombre = models.CharField(max_length=255, blank=True, null=True)
    emisor_cbu = models.CharField(max_length=22, blank=True, null=True)
    emisor_cuit = models.CharField(max_length=20, blank=True, null=True)
    fecha_detectada = models.DateTimeField(blank=True, null=True)

    class Meta:
        verbose_name = "Comprobante de pago"
        verbose_name_plural = "Comprobantes de pago"
        ordering = ("-created_at",)

    def __str__(self):
        return f"Comprobante #{self.pk} ‚Äì Turno {self.turno_id}"



class ConfiguracionPago(models.Model):
    destinatario = models.CharField(max_length=255)  # Ej: "Padel Club SRL"
    cbu = models.CharField(max_length=22)
    alias = models.CharField(max_length=100, blank=True)
    monto_esperado = models.DecimalField(max_digits=10, decimal_places=2)
    tiempo_maximo_minutos = models.IntegerField(default=60)

    actualizado_en = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"CBU: {self.cbu} ‚Äì Monto esperado: {self.monto_esperado}"


Y AUTH CORE estos

from django.contrib.auth.models import AbstractUser
from django.db import models

class Usuario(AbstractUser):
    email = models.EmailField(unique=True)
    telefono = models.CharField(max_length=20, blank=True)
    tipo_usuario = models.CharField(max_length=30, blank=True)

    USERNAME_FIELD = "email"
    REQUIRED_FIELDS = ["username"]

    def __str__(self):
        return self.email or self.username



estas son las especificaciones del backend

# üìò Especificaci√≥n T√©cnica de Endpoints - Proyecto CONDOR

## üîê Autenticaci√≥n JWT

| M√©todo | Endpoint                  | Descripci√≥n                                 |
|--------|---------------------------|---------------------------------------------|
| POST   | /api/token/             | Obtener access y refresh token              |
| POST   | /api/token/refresh/     | Refrescar access token usando refresh token |

---

## üè¢ Sedes

| M√©todo | Endpoint              | Descripci√≥n                     |
|--------|-----------------------|---------------------------------|
| GET    | /api/turnos/sedes/  | Listar todas las sedes disponibles |

---

## üéæ Turnos Generales (apps.turnos_core)

| M√©todo | Endpoint                                           | Descripci√≥n                                 |
|--------|----------------------------------------------------|---------------------------------------------|
| GET    | /api/turnos/turnos/disponibles/?lugar_id=&profesor_id=&fecha= | Obtener turnos libres por sede, profesor y fecha |
| POST   | /api/turnos/turnos/reservar/                     | Reservar un turno con comprobante adjunto   |

---

## üßë‚Äçüè´ Turnos Padel (apps.turnos_padel)

| M√©todo | Endpoint                                                       | Descripci√≥n                                           |
|--------|----------------------------------------------------------------|-------------------------------------------------------|
| GET    | /api/padel/profesores-disponibles/?lugar_id=                | Listar profesores con al menos un turno libre en sede |
| GET    | /api/padel/profesores/<profesor_id>/disponibilidades/       | Listar disponibilidades activas del profesor          |
| POST   | /api/padel/generar-turnos/                                   | Generar turnos autom√°ticamente seg√∫n disponibilidad   |

---

## üìÑ Comprobantes (apps.pagos_core)

| M√©todo | Endpoint                             | Descripci√≥n                         |
|--------|--------------------------------------|-------------------------------------|
| POST   | /api/comprobantes/                 | Subir comprobante de pago           |
| GET    | /api/comprobantes/<id>/descargar/ | Descargar comprobante por ID        |

---

## üë§ Autenticaci√≥n de Usuarios (apps.auth_core)

| M√©todo | Endpoint             | Descripci√≥n                     |
|--------|----------------------|---------------------------------|
| POST   | /api/auth/login/   | Login de usuario                |
| POST   | /api/auth/register/| Registro de nuevo usuario       |
| GET    | /api/auth/me/      | Obtener datos del usuario logueado |

---

## üß† Notas

- Todos los endpoints requieren Authorization: Bearer <access_token> salvo los p√∫blicos.
- Los turnos se generan autom√°ticamente en base a las disponibilidades del profesor.
- Los turnos ocupados tienen usuario != null, los libres tienen usuario == null.

---





asi genero una key nueva para base.py
python -c 'from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())'
